use crate::annotations::impl_helpers::impl_namespace;
use cairo_lang_sierra::program::StatementIdx;
use derive_more::{Add, AddAssign, Div, DivAssign, Mul, MulAssign, Sub, SubAssign};
use serde::{Deserialize, Deserializer, Serialize, Serializer};
use std::collections::HashMap;

/// Versioned representation of Coverage Annotations.
///
/// Always prefer using this enum when Serializing/Deserializing instead of inner ones.
#[derive(Clone, Debug, Eq, PartialEq)]
pub enum VersionedCoverageAnnotations {
    V1(CoverageAnnotationsV1),
}

/// The mapping from sierra statement index
/// to stack of a locations in Cairo code
/// which caused the statement to be generated.
/// And all functions that were inlined
/// or generated along the way up to the first non-inlined function from the original code.
///
/// The vector represents the stack from the least meaningful elements.
///
/// Introduced in Scarb 2.8.0.
///
/// Needs `unstable-add-statements-code-locations-debug-info = true`
/// under `[profile.dev.cairo]` in the Scarb config to be generated.
#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize)]
pub struct CoverageAnnotationsV1 {
    pub statements_code_locations: HashMap<StatementIdx, Vec<CodeLocation>>,
}

/// A location of Sierra statement.
#[derive(Clone, Debug, Eq, PartialEq, Hash, Serialize, Deserialize)]
pub struct CodeLocation(pub SourceFileFullPath, pub SourceCodeSpan);

/// A full path to a Cairo source file.
///
/// May contain multiple Cairo virtual file markings if the code is generated by macros.
/// Like `/path/to/project/lib.cairo[array_inline_macro][assert_macro]`
/// where `array_inline_macro` and `assert_macro` is a virtual file marking.
#[derive(Clone, Debug, Eq, PartialEq, Hash, Serialize, Deserialize)]
pub struct SourceFileFullPath(pub String);

/// A span in a Cairo source file.
#[derive(Clone, Debug, Eq, PartialEq, Hash, Serialize, Deserialize)]
pub struct SourceCodeSpan {
    /// Beginning of the text span in the Cairo source file.
    pub start: SourceCodeLocation,
    /// End of the text span in the Cairo source file. Currently, always the same as `start`.
    pub end: SourceCodeLocation,
}

/// A location in a Cairo source file.
#[derive(Clone, Debug, Eq, PartialEq, Hash, Serialize, Deserialize)]
pub struct SourceCodeLocation {
    /// Line index, 0 based.
    /// Most editors show line numbers starting from 1, so when displaying to users, add 1 to this value.
    pub line: LineNumber,
    /// Character index inside the line, 0 based.
    /// Most editors show column numbers starting from 1, so when displaying to users, add 1 to this value.
    pub col: ColumnNumber,
}

#[derive(
    Clone,
    Copy,
    Debug,
    Eq,
    PartialEq,
    Hash,
    Ord,
    PartialOrd,
    Serialize,
    Deserialize,
    Add,
    AddAssign,
    Sub,
    SubAssign,
    Mul,
    MulAssign,
    Div,
    DivAssign,
)]
pub struct ColumnNumber(pub usize);

#[derive(
    Clone,
    Copy,
    Debug,
    Eq,
    PartialEq,
    Hash,
    Ord,
    PartialOrd,
    Serialize,
    Deserialize,
    Add,
    AddAssign,
    Sub,
    SubAssign,
    Mul,
    MulAssign,
    Div,
    DivAssign,
)]
pub struct LineNumber(pub usize);

// We can't use untagged enum here. See https://github.com/serde-rs/json/issues/1103
impl Serialize for VersionedCoverageAnnotations {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        match self {
            VersionedCoverageAnnotations::V1(v1) => v1.serialize(serializer),
        }
    }
}

impl<'de> Deserialize<'de> for VersionedCoverageAnnotations {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        CoverageAnnotationsV1::deserialize(deserializer).map(VersionedCoverageAnnotations::V1)
    }
}

impl_namespace!(
    "github.com/software-mansion/cairo-coverage",
    CoverageAnnotationsV1,
    VersionedCoverageAnnotations
);
